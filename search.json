[{"title":"编码器","path":"/2023/04/15/编码器/","content":"参考文章 编码器（encoder）是将信号（如比特流）或数据进行编制、转换为可用以通讯、传输和存储的信号形式的设备。编码器把角位移或直线位移转换成电信号，前者称为码盘，后者称为码尺。 通用、高级定时器具有输入捕获功能，基本定时器没有 在高级、通用定时器中不全都有编码器接口模式，只有部分定时器具有编码器接口模式。 一个定时器有四个独立的输入通道CH1-4，但只有CHI,CH2，也就是TI1、TI2，能作为编码器接口的输入通道。 编码器接口简介•Encoder Interface 编码器接口 •编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度 •每个高级定时器和通用定时器都拥有1个编码器接口 •两个输入引脚借用了输入捕获的通道1和通道2","tags":["STM32"]},{"title":"定时器输入捕获","path":"/2023/04/15/定时器输入捕获/","content":"在输入捕获模式下，输入信号从GPIO进入到输入捕获通道，当输入引脚出现指定的电平变化之后，当前CNT的值将会被锁存到CCR中。例如，TI信号经过滤波器滤波之后将会得到TIF信号，经过带极性选择的边沿检测器之后得到TIF_Rising或是TIF_Faling信号，经过选择器之后输出TIFP1信号。TI1FP1、来自通道2的TI2FP1信号和来自从模式的TRC信号，经过选择器得到输入比较1信号IC1，再选择分频器分频，得到输入捕获&#x2F;比较寄存器的信号IC1PS。","tags":["STM32"]},{"title":"定时器输出比较","path":"/2023/04/14/定时器输出比较/","content":"参考文章 输出比较模式和PWM模式都可以用来输出PWM波，在功能上两者有相同之处，对于一个定时器这两种方式都可以做到四路输出PWM，每一路PWM占空比都可调，也有不同之处，输出比较模式可以方便的调节每一路PWM波的频率，可以输出四路频率不同，占空比不同的PWM。但是PWM模式如果想要调节PWM波的频率，那么就只能重新设置预分频系数或者自动重装载寄存器ARR，并且输出的四路PWM频率必定一致。 PWM模式下的信号由自动重装在寄存器ARR进行确定，占空比由比较寄存器CCR进行确定。 在PWM模式下的时候，我们可以通过改变预分频系数PSC以及自动重装载值ARR对PWM波的占空比以及频率进行调节。 PWM频率 &#x3D;（系统时钟频率）&#x2F;((ARR+1)*(PSC+1))(单位：Hz) PWM的占空比是由CCR寄存器进行决定的，占空比计算方法 DUTY&#x3D;CCR&#x2F;ARR。 一般来说，好像在stm32中ARR与PSC还有CCR的设置通常比要设置的值少1.（相关的问题建议去看江科大up主的定时器的视频）。","tags":["STM32"]},{"title":"定时器框图解读","path":"/2023/04/14/定时器框图解读/","content":"定时器系统框图 参考文章 上述框图可以说是学习STM32嵌入式必须掌握的一张图。加油！ 上述框图可以分为四个大部分： 图片来源于http://t.csdn.cn/73HFs CK_INT是STM32内部时钟，例如STM32的时钟是72MHz，那么定时器的时钟就是72MHz，通常的开发中一般也是使用这个。 ETR是外部时钟，接入外部的时钟作为定时器的计数时钟。 ITRx接通的是其他的定时器，STM32中多个定时器都是链接在一起的，相当于并联吧。例如定时器1可以作为一个定时器使用，每当定时器1计数满之后就可以产生一个上升沿或是下降沿，这样连接到定时器2中，定时器2的计数值加1。这样做可以做到延时时间大大加长，例如一个定时器最大能计数59秒，那么当并联之后，可以定时59*65536秒&#x3D;1820小时，已经非常久了。 在输入捕获模式下，输入信号从GPIO进入到输入捕获通道，当输入引脚出现指定的电平变化之后，当前CNT的值将会被锁存到CCR中。例如，TI信号经过滤波器滤波之后将会得到TIF信号，经过带极性选择的边沿检测器之后得到TIF_Rising或是TIF_Faling信号，经过选择器之后输出TIFP1信号。TI1FP1、来自通道2的TI2FP1信号和来自从模式的TRC信号，经过选择器得到输入比较1信号IC1，再选择分频器分频，得到输入捕获&#x2F;比较寄存器的信号IC1PS。","tags":["STM32"]},{"title":"预分频器及其计算","path":"/2023/04/14/预分频器及其计算/","content":"预分频器（PSC）是用来对定时器的时钟源进行分频的。它可以将计数器的时钟频率按1到65536之间的任意值分频。，是16位的正整数值，它的可调节范围是1-65536，可以对定时器进行分频计数。 其实理解起来就是对72MHz的时钟进行变小，72MHz就是将1秒分为72000000等分，每经过1000000&#x2F;72000000秒之后定时器计数器（16位）的值就会加一或是减一。那么从0计数到到65536需要的时间是1*65536&#x2F;72us。 分频之后用于定时计数器的时钟频率为1000000&#x2F;(72000000&#x2F;PSC)秒，即1000000us的系数变小了，那么时间就变大咯。和cubemx里面的配置一样，就像蓝桥杯是配置10ms的时间一样。 •计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1) ​ &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)","tags":["STM32"]},{"title":"舵机","path":"/2023/04/14/舵机/","content":"舵机的工作原理参考博主的解释。 舵机是一种被广泛运用的执行部件，各个领域广受欢迎，能够用于机器人的运动控制等。 舵机上有三根线，分别是GND、VCC和SIG，也就是地线、电源线和信号线，其中的PWM波就是从信号线输入给舵机。 舵机接收的PWM信号频率为50HZ，即周期为20ms。当高电平的脉宽在0.5ms-2.5ms之间时舵机就可以对应旋转到不同的角度。 12345t = 0.5ms——————-舵机会转到 0 °t = 1.0ms——————-舵机会转到 45°t = 1.5ms——————-舵机会转到 90°t = 2.0ms——————-舵机会转到 135°t = 2.5ms——————-舵机会转到 180° 1T= 1/f=1/50=0.02s=20ms","tags":["STM32"]},{"title":"5.OLED","path":"/2023/04/14/OLED/","content":"江科大自化协UP主的代码：我不会写 1234567891011121314#ifndef __OLED_H#define __OLED_Hvoid OLED_Init(void);void OLED_Clear(void);void OLED_ShowChar(uint8_t Line, uint8_t Column, char Char);void OLED_ShowString(uint8_t Line, uint8_t Column, char *String);void OLED_ShowNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length);void OLED_ShowSignedNum(uint8_t Line, uint8_t Column, int32_t Number, uint8_t Length);void OLED_ShowHexNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length);void OLED_ShowBinNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include &quot;stm32f10x.h&quot;#include &quot;OLED_Font.h&quot;/*引脚配置*/#define OLED_W_SCL(x) GPIO_WriteBit(GPIOB, GPIO_Pin_8, (BitAction)(x))#define OLED_W_SDA(x) GPIO_WriteBit(GPIOB, GPIO_Pin_9, (BitAction)(x))/*引脚初始化*/void OLED_I2C_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOB, &amp;GPIO_InitStructure);\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); OLED_W_SCL(1);\tOLED_W_SDA(1);&#125;/** * @brief I2C开始 * @param 无 * @retval 无 */void OLED_I2C_Start(void)&#123;\tOLED_W_SDA(1);\tOLED_W_SCL(1);\tOLED_W_SDA(0);\tOLED_W_SCL(0);&#125;/** * @brief I2C停止 * @param 无 * @retval 无 */void OLED_I2C_Stop(void)&#123;\tOLED_W_SDA(0);\tOLED_W_SCL(1);\tOLED_W_SDA(1);&#125;/** * @brief I2C发送一个字节 * @param Byte 要发送的一个字节 * @retval 无 */void OLED_I2C_SendByte(uint8_t Byte)&#123;\tuint8_t i;\tfor (i = 0; i &lt; 8; i++)\t&#123; OLED_W_SDA(Byte &amp; (0x80 &gt;&gt; i)); OLED_W_SCL(1); OLED_W_SCL(0);\t&#125;\tOLED_W_SCL(1);\t//额外的一个时钟，不处理应答信号\tOLED_W_SCL(0);&#125;/** * @brief OLED写命令 * @param Command 要写入的命令 * @retval 无 */void OLED_WriteCommand(uint8_t Command)&#123;\tOLED_I2C_Start();\tOLED_I2C_SendByte(0x78); //从机地址\tOLED_I2C_SendByte(0x00); //写命令\tOLED_I2C_SendByte(Command); OLED_I2C_Stop();&#125;/** * @brief OLED写数据 * @param Data 要写入的数据 * @retval 无 */void OLED_WriteData(uint8_t Data)&#123;\tOLED_I2C_Start();\tOLED_I2C_SendByte(0x78); //从机地址\tOLED_I2C_SendByte(0x40); //写数据\tOLED_I2C_SendByte(Data);\tOLED_I2C_Stop();&#125;/** * @brief OLED设置光标位置 * @param Y 以左上角为原点，向下方向的坐标，范围：0~7 * @param X 以左上角为原点，向右方向的坐标，范围：0~127 * @retval 无 */void OLED_SetCursor(uint8_t Y, uint8_t X)&#123;\tOLED_WriteCommand(0xB0 | Y); //设置Y位置\tOLED_WriteCommand(0x10 | ((X &amp; 0xF0) &gt;&gt; 4));\t//设置X位置高4位\tOLED_WriteCommand(0x00 | (X &amp; 0x0F)); //设置X位置低4位&#125;/** * @brief OLED清屏 * @param 无 * @retval 无 */void OLED_Clear(void)&#123; uint8_t i, j;\tfor (j = 0; j &lt; 8; j++)\t&#123; OLED_SetCursor(j, 0); for(i = 0; i &lt; 128; i++) &#123; OLED_WriteData(0x00); &#125;\t&#125;&#125;/** * @brief OLED显示一个字符 * @param Line 行位置，范围：1~4 * @param Column 列位置，范围：1~16 * @param Char 要显示的一个字符，范围：ASCII可见字符 * @retval 无 */void OLED_ShowChar(uint8_t Line, uint8_t Column, char Char)&#123; uint8_t i;\tOLED_SetCursor((Line - 1) * 2, (Column - 1) * 8); //设置光标位置在上半部分\tfor (i = 0; i &lt; 8; i++)\t&#123; OLED_WriteData(OLED_F8x16[Char - &#x27; &#x27;][i]); //显示上半部分内容\t&#125;\tOLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 8);\t//设置光标位置在下半部分\tfor (i = 0; i &lt; 8; i++)\t&#123; OLED_WriteData(OLED_F8x16[Char - &#x27; &#x27;][i + 8]); //显示下半部分内容\t&#125;&#125;/** * @brief OLED显示字符串 * @param Line 起始行位置，范围：1~4 * @param Column 起始列位置，范围：1~16 * @param String 要显示的字符串，范围：ASCII可见字符 * @retval 无 */void OLED_ShowString(uint8_t Line, uint8_t Column, char *String)&#123;\tuint8_t i;\tfor (i = 0; String[i] != &#x27;\\0&#x27;; i++)\t&#123; OLED_ShowChar(Line, Column + i, String[i]);\t&#125;&#125;/** * @brief OLED次方函数 * @retval 返回值等于X的Y次方 */uint32_t OLED_Pow(uint32_t X, uint32_t Y)&#123;\tuint32_t Result = 1;\twhile (Y--)\t&#123; Result *= X;\t&#125;\treturn Result;&#125;/** * @brief OLED显示数字（十进制，正数） * @param Line 起始行位置，范围：1~4 * @param Column 起始列位置，范围：1~16 * @param Number 要显示的数字，范围：0~4294967295 * @param Length 要显示数字的长度，范围：1~10 * @retval 无 */void OLED_ShowNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)&#123;\tuint8_t i;\tfor (i = 0; i &lt; Length; i++) &#123; OLED_ShowChar(Line, Column + i, Number / OLED_Pow(10, Length - i - 1) % 10 + &#x27;0&#x27;);\t&#125;&#125;/** * @brief OLED显示数字（十进制，带符号数） * @param Line 起始行位置，范围：1~4 * @param Column 起始列位置，范围：1~16 * @param Number 要显示的数字，范围：-2147483648~2147483647 * @param Length 要显示数字的长度，范围：1~10 * @retval 无 */void OLED_ShowSignedNum(uint8_t Line, uint8_t Column, int32_t Number, uint8_t Length)&#123;\tuint8_t i;\tuint32_t Number1;\tif (Number &gt;= 0)\t&#123; OLED_ShowChar(Line, Column, &#x27;+&#x27;); Number1 = Number;\t&#125;\telse\t&#123; OLED_ShowChar(Line, Column, &#x27;-&#x27;); Number1 = -Number;\t&#125;\tfor (i = 0; i &lt; Length; i++) &#123; OLED_ShowChar(Line, Column + i + 1, Number1 / OLED_Pow(10, Length - i - 1) % 10 + &#x27;0&#x27;);\t&#125;&#125;/** * @brief OLED显示数字（十六进制，正数） * @param Line 起始行位置，范围：1~4 * @param Column 起始列位置，范围：1~16 * @param Number 要显示的数字，范围：0~0xFFFFFFFF * @param Length 要显示数字的长度，范围：1~8 * @retval 无 */void OLED_ShowHexNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)&#123;\tuint8_t i, SingleNumber;\tfor (i = 0; i &lt; Length; i++) &#123; SingleNumber = Number / OLED_Pow(16, Length - i - 1) % 16; if (SingleNumber &lt; 10) &#123; OLED_ShowChar(Line, Column + i, SingleNumber + &#x27;0&#x27;); &#125; else &#123; OLED_ShowChar(Line, Column + i, SingleNumber - 10 + &#x27;A&#x27;); &#125;\t&#125;&#125;/** * @brief OLED显示数字（二进制，正数） * @param Line 起始行位置，范围：1~4 * @param Column 起始列位置，范围：1~16 * @param Number 要显示的数字，范围：0~1111 1111 1111 1111 * @param Length 要显示数字的长度，范围：1~16 * @retval 无 */void OLED_ShowBinNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)&#123;\tuint8_t i;\tfor (i = 0; i &lt; Length; i++) &#123; OLED_ShowChar(Line, Column + i, Number / OLED_Pow(2, Length - i - 1) % 2 + &#x27;0&#x27;);\t&#125;&#125;/** * @brief OLED初始化 * @param 无 * @retval 无 */void OLED_Init(void)&#123;\tuint32_t i, j; for (i = 0; i &lt; 1000; i++) //上电延时\t&#123; for (j = 0; j &lt; 1000; j++);\t&#125; OLED_I2C_Init(); //端口初始化 OLED_WriteCommand(0xAE);\t//关闭显示 OLED_WriteCommand(0xD5);\t//设置显示时钟分频比/振荡器频率\tOLED_WriteCommand(0x80); OLED_WriteCommand(0xA8);\t//设置多路复用率\tOLED_WriteCommand(0x3F); OLED_WriteCommand(0xD3);\t//设置显示偏移\tOLED_WriteCommand(0x00); OLED_WriteCommand(0x40);\t//设置显示开始行 OLED_WriteCommand(0xA1);\t//设置左右方向，0xA1正常 0xA0左右反置 OLED_WriteCommand(0xC8);\t//设置上下方向，0xC8正常 0xC0上下反置\tOLED_WriteCommand(0xDA);\t//设置COM引脚硬件配置\tOLED_WriteCommand(0x12); OLED_WriteCommand(0x81);\t//设置对比度控制\tOLED_WriteCommand(0xCF);\tOLED_WriteCommand(0xD9);\t//设置预充电周期\tOLED_WriteCommand(0xF1);\tOLED_WriteCommand(0xDB);\t//设置VCOMH取消选择级别\tOLED_WriteCommand(0x30);\tOLED_WriteCommand(0xA4);\t//设置整个显示打开/关闭\tOLED_WriteCommand(0xA6);\t//设置正常/倒转显示\tOLED_WriteCommand(0x8D);\t//设置充电泵\tOLED_WriteCommand(0x14);\tOLED_WriteCommand(0xAF);\t//开启显示 OLED_Clear(); //OLED清屏&#125;","tags":["STM32"]},{"title":"基于江科大自化协UP主串口代码的理解","path":"/2023/04/14/基于江科大自化协UP主代码的理解/","content":"usart_printf 123#include &quot;usart.h&quot;uint8_t usart_RxFlag = 0;//接收状态标志位uint8_t usart_RxData = 0;//数据存储 串口初始化，STM32F103C8T6串口1的引脚为PA.9,PA.10，PA9为TX，PA10为RX。 123456789101112131415161718192021222324252627282930313233343536void usart_init(u32 baudRate)&#123; GPIO_InitTypeDef GPIO_InitStruct; USART_InitTypeDef USART_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; // 管脚复用模式,TX GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStruct); USART_InitStruct.USART_BaudRate = baudRate; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART1, &amp;USART_InitStruct); USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // 开启中断，USART_IT_RXNE表示接收中断 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //中断分组 NVIC_InitTypeDef NVIC_InitStruct; NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; NVIC_Init(&amp;NVIC_InitStruct); USART_Cmd(USART1, ENABLE);&#125; 以下代码为发送数据函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344void usart_sendByte(u8 data) // 发送一个字节&#123; USART_SendData(USART1, data); // 库函数 while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET) ; // 等待发送完成&#125;void usart_sendArray(uint8_t *data, uint16_t len) // 发送数组&#123; uint16_t i; for (i = 0; i &lt; len; i++) &#123; usart_sendByte(data[i]); &#125;&#125;void usart_sendString(char *str) // 发送字符串&#123; uint8_t i = 0; for (i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; usart_sendByte(str[i]); &#125;&#125;uint32_t usart_Pow(uint32_t X, uint32_t Y) // 计算X的Y次方&#123; uint32_t Result = 1; while (Y--) &#123; Result *= X; &#125; return Result;&#125;void usart_sendNumber(uint32_t num, uint8_t len) // 发送数字&#123; uint8_t i = 0; for (i = 0; i &lt; len; i++) &#123; usart_sendByte(num / usart_Pow(10, len - i - 1) % 10 + &#x27;0&#x27;); // 发送数字的每一位 &#125;&#125; printf重定向 12345678910111213141516int fputc(int ch, FILE *f) // 重定向printf函数&#123; usart_sendByte(ch); // 发送一个字节 return ch;&#125;void usart_printf(char *format, ...) // 重定向printf函数&#123; char String[100]; // 定义一个字符串数组 va_list arg; // 定义一个va_list类型的变量，用来储存单个参数 va_start(arg, format); // 使arg指向可变参数format的第一个参数 vsprintf(String, format, arg); // 将可变参数format格式化为字符串存入String中 va_end(arg); // 结束可变参数的获取 usart_sendString(String); // 发送字符串&#125; 串口中断相关处理函数 1234567891011121314151617181920212223242526272829//如果接收到串口发送来的数据，则将标志位置位uint8_t usart_GetRxFlag() // 获取接收到数据标志位&#123; if (usart_RxFlag == 1) // 接收到数据 &#123; usart_RxFlag = 0; // 接收到数据标志位置0 return 1; &#125; else &#123; return 0; &#125;&#125;//返回接收到的数据uint8_t usart_GetRxData() // 获取接收到的数据&#123; return usart_RxData; // 返回接收到的数据&#125;//如果串口中收到发来的数据那么就将接收到的数据，那么将会触发该中断函数//该中断函数将接收到的数据保存到usart_RxData中void USART1_IRQHandler(void) // 中断服务函数&#123; if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) // 接收中断 &#123; usart_RxData = USART_ReceiveData(USART1); // 读取接收到的数据 usart_RxFlag = 1; // 接收到数据标志位置1 USART_ClearITPendingBit(USART1, USART_IT_RXNE); // 清除中断标志位 &#125;&#125; 主函数 1234567891011121314int main()&#123;\tusart_init(9600);\tuint8_t RXData;\twhile (1)\t&#123; if(usart_GetRxFlag()==1)//接收到数据 &#123; RXData=usart_GetRxData();//获取接收到的数据// usart_sendByte(RXData);//发送数据 usart_printf(&quot;%c&quot;,RXData); &#125;\t&#125;&#125;","tags":["STM32"]},{"title":"printf重定向","path":"/2023/04/14/printf重定向/","content":"在C语言中，我们向显示器发送数据的函数是printf函数，在嵌入式相关的开发中，为了使用printf函数将数据发送到串口将串口作为其显示硬件，我们需要重定向print。代码如下： 12345678910111213141516int fputc(int ch,FILE *f)//重定向printf函数&#123; usart_sendByte(ch); return ch;&#125;void usart_printf(char *format)//重定向printf函数&#123; char String[100];//定义一个字符串数组 va_list arg;//定义一个va_list类型的变量，用来储存单个参数 va_start(arg,format);//使arg指向可变参数format的第一个参数 vsprintf(String,format,arg);//将可变参数format格式化为字符串存入String中 va_end(arg);//结束可变参数的获取 usart_sendString(String);//发送字符串&#125;//代码参考江科大自化协UP主代码","tags":["STM32"]},{"title":"串口发送数据如何直接将数字发送出去？","path":"/2023/04/14/串口发送数据如何直接将数字发送出去？/","content":"有时候串口需要发送一些数据，这些数据有可能是数字，数字的发送需要先将其转换为字符串。代码如下： 12345678910111213141516171819uint32_t usart_Pow(uint32_t X,uint32_t Y)//计算X的Y次方&#123; uint32_t Result=1; while(Y--) &#123; Result*=X; &#125; return Result;&#125;void usart_sendNumber(uint32_t num,uint8_t len)//发送数字&#123; uint8_t i=0; for(i=0;i&lt;len;i++) &#123; usart_sendByte(num/usart_Pow(10,len-i-1)%10+&#x27;0&#x27;); &#125;&#125; usart_Pow()函数计算的是X的Y次方，该函数在usart_sendNumber()中被调用，num&#x2F;usart_Pow(10,len-i-1)%10+’0’将第i位数字提取出来，加上‘0’之后就可以转换为字符逐个发送。","tags":["STM32"]},{"title":"GPIO的八种工作模式","path":"/2023/04/14/GPIO的八种工作模式/","content":"HSUD GPIO_Mode_AIN 模拟输入 GPIO_Mode_IN_FLOATING 浮空输入 GPIO_Mode_IPD 下拉输入 GPIO_Mode_IPU 上拉输入 GPIO_Mode_Out_OD 开漏输出 GPIO_Mode_Out_PP 推挽输出 GPIO_Mode_AF_OD 复用开漏输出 GPIO_Mode_AF_PP 复用推挽输出","tags":["STM32"]},{"title":"4.串口中断程序解读","path":"/2023/04/13/串口中断程序解读/","content":"IO端口、初始化 123GPIO_InitTypeDef GPIO_InitStructure;//GPIO端口USART_InitTypeDef USART_InitStructure;//串口NVIC_InitTypeDef NVIC_InitStructure;//中断 串口及IO端口时钟使能，STM32F103C8芯片中，串口1的的IO端口是A，同时，需要将串口1使能。 1RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE); IO端口输入输出初始化配置 123456789//USART1_TX GPIOA.9GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出模式GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9//USART1_RX GPIOA.10初始化GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 中断优先级配置，此处配置抢占优先级为3，子优先级为3 12345NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//转换为抢占优先级3NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能NVIC_Init(&amp;NVIC_InitStructure);\t//根据指定的参数初始化NVIC寄存器 波特率、数据位数、奇偶校验等模式配置 USART_InitStructure.USART_BaudRate &#x3D; bound;&#x2F;&#x2F;波特率 USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;设置字长为8位数据格式 USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;一个停止位 USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;无奇偶校验 USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;&#x2F;&#x2F;无硬件数据流控制 USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;\t&#x2F;&#x2F;收发模式 123USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断USART_Cmd(USART1, ENABLE); //使能串口1 中断服务函数。在串口程序中，没怎么看懂里面的意思，但是需要知道里面相关的函数知识，USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)这个函数来判断是不是因为接收到数据而触发中断，如果是由于串口数据的收发引起的中断则会进入到中断函数中 首先强调一点0x0d和0x0a在ASCII码表里面表示\\r和 ，分别表示回车和换行 123456789101112131415161718192021222324252627void USART1_IRQHandler(void) //串口1中断服务程序\t&#123;\tu8 Res;\tif(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断（接收道德数据必须是0x0d 0x0a结尾） &#123; Res =USART_ReceiveData(USART1);\t//读取接收到的数据 if((USART_RX_STA&amp;0x8000)==0)//接收未完成 &#123; if(USART_RX_STA&amp;0x4000)//接收到了0x0d &#123; if(Res!=0x0a)USART_RX_STA=0;//接收错误，重新开始 else USART_RX_STA|=0x8000;\t//接收完成了 &#125; else//还没有接收到0x0D &#123; if(Res==0x0d)USART_RX_STA|=0x4000; else &#123; USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ; USART_RX_STA++; if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误， 重新开始接收 &#125; &#125; &#125; &#125; &#125; 根据CSDN一位博主的描述：“这段代码是定义了一个协议，你所向单片机发送的字符必须以“&#x2F;r&#x2F;n”结尾（关于&#x2F;r和&#x2F;n，文章最后有补充说明），然后在中断函数里面通过判断\\r和 的ascll值使定义的 USART1_RX_STA 这个“状态寄存器”的相应位置1，然后在主函数里面判断 USART1_RX_STA这个“状态寄存器”的标志位的值，来发送数据。” 这位博主写的真的很好，这里我直接复制粘贴了。 先说说这段代码的整体设计思路，这段代码是定义了一个协议，你所向单片机发送的字符必须以“&#x2F;r&#x2F;n”结尾（关于&#x2F;r和&#x2F;n，文章最后有补充说明），然后在中断函数里面通过判断\\r和 的ascll值使定义的 USART1_RX_STA 这个“状态寄存器”的相应位置1，然后在主函数里面判断 USART1_RX_STA这个“状态寄存器”的标志位的值，来发送数据。 看完之后是不是觉得很神奇，USART1_RX_STA明明是定义的一个变量，怎么就变成“寄存器了”，这就是设计师奇妙的设计，定义的USART1_RX_STA是两个字节的变量，有16个位可以用，但是我们的最大接收字节只要200个，就算有1000个字节我们也用不到2的15次方的大小，字节再多stm32就没这么大的存储空间了，所以200个字节已经足够我们一次接收的数据了。显然16个位我们是用不完的，所以我们可以把USART1_RX_STA的高位设置成状态标志位，低位用来计数。如图所示 图中可以看到，0-13位用来记录字符的长度，高两位作为状态标志位。下面开始正式讲解代码。 1234567891011121314151617181920212223242526void USART1_IRQHandler(void) //串口1中断服务程序&#123;1\tu8 r;2\tif(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断3\t&#123;4 r =USART_ReceiveData(USART1);//(USART1-&gt;DR);\t//读取接收到的数据5 if((USART1_RX_STA&amp;0x8000)==0)//接收未完成6 &#123;7 if(USART1_RX_STA&amp;0x4000)//接收到了0x0d8 &#123;9 if(r!=0x0a)USART1_RX_STA=0;//接收错误,重新开始10 else USART1_RX_STA|=0x8000;\t//接收完成了 11 &#125;12 else //接收到0X0D之前或0x0D13 &#123;\t14 if(r==0x0d)USART1_RX_STA|=0x4000;15 else16 &#123;17 USART1_RX_BUF[USART1_RX_STA&amp;0X3FFF]=r;18 USART1_RX_STA++;19 if(USART1_RX_STA&gt;(USART1_REC_LEN-1))USART1_RX_STA=0;//接收数据错误,重新开始接收 &#125; &#125; &#125; &#125; &#125; 1.当接收到数据时，会产生接收中断，进入中断函数，将接收到的数据存入变量r中，注意，r只占一个字节。 2.代码第5行，判断最高位的状态，USART1_RX_STA最高位是接收到 (0x0a),才会置1的状态标志位，当它置1时，标志着整个数据已经接收完毕，main中就是判断这个位是否为1来进行发送数据的。很显然，能够进入中断，那说明接收还未完成，所以接下来就是执行第5行下面的代码。 3.第7行是判断USART1_RX_STA次高位，USART1_RX_STA次高位是否置1，这要取决于是否接收到了倒数第2个字符0x0d。 如果上一次接收中断接收到了0x0d，就会把次高位置1，代码第7行检测到了USART1_RX_STA次高位置1后，就会进入if里面（执行代码第9或者第10行），判断数据最后一位是否是0x0a( )，如果最后一位不是0x0a，那说明这串字符不是按照程序所定义的协议发送给单片机的，单片机自然也就识别不了，这个数据就会被丢掉（代码第9行），USART1_RX_STA清零（包括里面的记录的数据长度和状态标志位），重新接收新的发送过来的数据；如果最后一位是0x0a，那这个字符串就是按照协议发送给单片机的，程序执行第10行，将USART1_RX_STA的最高位置1，标志这串字符串接收完毕。USART1_RX_STA最高位置1后，main函数中就可以检测它进行操作了。如果上一次接收中断未接收到了0x0d，那么USART1_RX_STA次高位就不会被置1，在程序走到第7行时，检测到USART1_RX_STA次高位为0，程序就会执行第12行的else。4.程序第12行的else中，要判断接收到的数据是0x0d还是0x0d之前的数据。 如果这个数据是0x0d，那么就将USART1_RX_STA次高位置1，在下一次进入接收中断时，就会执行上述3中的步骤了，程序第7行就能够检测到USART1_RX_STA次高位的状态了。如果这个数据是0x0d之前的数据，就执行17-19行代码，这三行代码的作用是将这个字节存入USART1_RX_BUF[USART1_REC_LEN]数组（头文件中定义过了）中，记录字符的长度，判断字符长度是否发生溢出（最大200字节）。USART1_RX_BUF[USART1_RX_STA&amp;0X3FFF]&#x3D;r;说明一下这行代码中的USART1_RX_STA&amp;0X3FFF，USART1_RX_STA的0-13位时用来记录数据长度的，这句话的意思就是去掉了USART1_RX_STA中的高两位状态位，剩下的数据与数组的值相对应。5.看了上面4点解释脑子里是不是还是很乱，这也就是这段代码难的地方，不能够顺序的去看这个代码，不然还是理不清逻辑，这个串口中断，就相当于一个循环，要判断到接收数据完毕了才会结束这个循环，怎么判断结束是否完毕呢？就看USART1_RX_STA的高两位的状态。下面再来屡屡逻辑。 [0] 来了一串数据，假设有50个字符，占50个字节，再加上协议定义的结尾\\r ，一共是52个字节。 [1] 当接收到0x0d(\\r,也是第51个字符)之前的字符，串口中断函数执行的过程是前4行执行完，第5行条件成立进入if，执行到第7行时，条件不成立，转至12行，此时14行进行判断，这个字符不是0x0d，条件不成立，执行17-19行，将数据存入数组中。 [2] 当0x0d前面的数据接收完时，下一个到来的字符是0x0d(\\r)时，此时USART1_RX_STA的最高位和次高位都还是0，程序执行到第7行时，条件依然不会成立，程序会跳转置12行的else，此时程序14行的判断成立，会将USART1_RX_STA的次高位置1，然后结束这次中断。 [3] 接着上面的步骤，0x0d过了是最后一个字符0x0a( )，当接收到这个字符时，第5行条件成立，进入if，执行到程序第7行时，由于上一步接收到了0x0d，已经把USART1_RX_STA的次高位置1了，程序就进入if，执行8-11行的代码，判断是否是0x0a，如果不是，执行程序第9行，如果是，执行第10行，将USART1_RX_STA最高位置1，此时整个数据接收就完成了，剩下的交给主函数处理了。 接下来是主函数的处理程序了，把这个串口中断函数理解清楚了，主函数也就好理解了。版权声明：本文为CSDN博主「轻染QAQ」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47586883/article/details/110959012 1234567891011121314151617181920212223int main()&#123;\tu16 t=0;\tu16 len=0; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //中断优先级分组 分2组\tUSART1_Init(115200); while(1)\t&#123; if(USART1_RX_STA&amp;0x8000) &#123; len=USART1_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 for(t=0;t&lt;len;t++) &#123; USART_SendData(USART1, USART1_RX_BUF[t]); //向串口1发送数据 while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//等待发送结束 &#125; USART1_RX_STA=0; &#125; &#125; 主函数while里面，首先判断USART1_RX_STA的最高位，看数据是否接收完毕，再进行操作。 len是记下的数据长度，用于for循环中数据发送的次数（因为每次只能发送一个字节）。 for循环中的while是用的串口发送完成的标志位来判断的是否发送完毕。 最后一定要把USART1_RX_STA置0，方便下次的数据接收，这很重要！！！ 版权声明：本文为CSDN博主「轻染QAQ」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47586883/article/details/110959012 补充，关于\\r和 回车 \\r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return。ASCII码13(0x0d)。换行 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed。ASCII码10(0x0a)。Windows系统中，我们键盘上的enter键，按下就是\\r 。所以也是为什么要在串口中定义这个协议。当输入一串字符之后按下回车键，点击发送，可以在右边的框中看到最后两个字符的十六进制码是0x0d和0x0a。 版权声明：本文为CSDN博主「轻染QAQ」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47586883/article/details/110959012 参考文章： 《STM32不完全手册_库函数版本_V3.3》 http://t.csdn.cn/dXaFm","tags":["STM32"]},{"title":"3.串口通信初理解","path":"/2023/04/13/串口通信/","content":"串口通信有一下几个步骤 串口时钟使能，GPIO 时钟使能 串口复位 GPIO端口模式设置 串口参数初始化 开启中断并且初始化NVIC（若是中断开发需要设置） 使能串口 编写中断处理函数 相关函数 串口时钟使能，GPIO 时钟使能 1RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1)； 串口复位。当外设出现异常的时复位设置，实现该外设的复位，然后重新配置 这个外设达到让其重新工作的目的。一般在系统刚开始配置外设的时候，都会先执行复位该外 设的操作。复位的是在函数 USART_DeInit()中完成： 1void USART_DeInit(USART_TypeDef* USARTx);//串口复位 串口参数初始化，串口初始化是通过 USART_Init()函数实现的。 1void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)； 这个函数得第一个参数是指定的串口标号，而第二个参数是一个USART_InitTypeDef类型得结构体指针，该结构体成员的参数需要进行一定的配置。 1234567USART_InitStructure.USART_BaudRate = bound; //波特率;USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为 8 位数据格式USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位USART_InitStructure.USART_HardwareFlowControl= USART_HardwareFlowControl_None; //无硬件数据流控制USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式USART_Init(USART1, &amp;USART_InitStructure); //初始化串口 初始化需要设置的参数为：波特率，字长，停止位，奇偶校验位， 硬件数据流控制，模式（收，发）。 数据发送与接收。STM32 的发送与接收是通过数据寄存器 USART_DR 来实现的，这是 一个双寄存器，包含了 TDR 和 RDR。当向该寄存器写数据的时候，串口就会自动发送，当收 到收据的时候，也是存在该寄存器内。 STM32 库函数操作 USART_DR 寄存器发送数据的函数是： 1void USART_SendData(USART_TypeDef* USARTx, uint16_t Data); 通过该函数向串口寄存器 USART_DR 写入一个数据。 STM32 库函数操作 USART_DR 寄存器读取串口接收到的数据的函数是： 1uint16_t USART_ReceiveData(USART_TypeDef* USARTx); 通过该函数可以读取串口接受到的数据。 串口状态。串口的状态可以通过状态寄存器 USART_SR 读取。USART_SR 的各位描述如下图： RXNE（读数据寄存器非空），当该位被置 1 的时候，就是提示已经有数据被接收到了，并 且可以读出来了。这时候我们要做的就是尽快去读取 USART_DR，通过读 USART_DR 可以将 该位清零，也可以向该位写 0，直接清除。 TC（发送完成），当该位被置位的时候，表示 USART_DR 内的数据已经被发送完成了。如 果设置了这个位的中断，则会产生中断。该位也有两种清零方式：1）读 USART_SR，写 USART_DR。2）直接向该位写 0。 1FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)； 函数的第二个入口参数非常关键，它是标示我们要查看串口的哪种状态，比如上面讲解的 RXNE(读数据寄存器非空)以及 TC(发送完成)。例如我们要判断读寄存器是否非空(RXNE)，操 作库函数的方法是： 1USART_GetFlagStatus(USART1, USART_FLAG_RXNE)； 我们要判断发送是否完成(TC)，操作库函数的方法是： 1USART_GetFlagStatus(USART1, USART_FLAG_TC); 串口使能 1USART_Cmd(USART1, ENABLE); //使能串口 开启串口响应中断。有些时候当我们还需要开启串口中断，那么我们还需要使能串口中 断，使能串口中断的函数是： 1void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState) 函数的第二个入口参数是标示使能串口的类型，也就是使能哪种中断，因为串口的中断类 型有很多种。比如在接收到数据的时候（RXNE 读数据寄存器非空），我们要产生中断，那么我 们开启中断的方法是： 1USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断，接收到数据中断 获取相应中断状态。当我们使能了某个中断的时候，当该中断发生了，就会设置状态寄 存器中的某个标志位。经常我们在中断处理函数中，要判断该中断是哪种中断，使用的函数是： 1ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT) 比如我们使能了串口发送完成中断，那么当中断发生了， 我们便可以在中断处理函数中调用这 个函数来判断到底是否是串口发送完成中断，方法是： 1USART_GetITStatus(USART1, USART_IT_TC) 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]},{"title":"2. 按键输入","path":"/2023/04/13/按键输入/","content":"按键输入使用的是浮空输入。 key.c 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;key.h&quot;#include &quot;port.h&quot;#define KEY0 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)#define KEY1 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1)void key_init()&#123;\tGPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#125;unsigned char key_Scan()&#123; if(KEY0==0) &#123; delay_ms(10); if(KEY0==0) &#123; while(!KEY0); delay_ms(10); return 1; &#125; &#125; if(KEY1==0) &#123; delay_ms(10); if(KEY1==0) &#123; while(!KEY1); delay_ms(10); return 2; &#125; &#125; return 0;&#125; key.h 123456789#ifndef __KEY_H#define __KEY_H#include &quot;stm32f10x.h&quot; // Device header#include &quot;delay.h&quot;unsigned char key_Scan();void key_init();#endif protuse按键仿真：在protuse仿真中只能使将按钮配置为上拉输入或是下拉输入，否则将会出现按键功能无法实现得情况，此外按键只能如图接法，接上拉电阻或是下拉电阻同样无法生效。 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]},{"title":"1. 点亮我的第一个LED小灯","path":"/2023/04/13/点亮我的第一个LED小灯/","content":"123456789101112131415161718192021222324#include &quot;stm32f10x.h&quot; // Device header#include &quot;port.h&quot;//位带操作#include &quot;delay.h&quot;//延时函数void led_init()&#123;\tGPIO_InitTypeDef GPIO_InitStruct;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125;int main()&#123;\tled_init();\tdelay_init();\twhile(1)\t&#123; PAout(0)=1; delay_ms(1000); PAout(0)=0; delay_ms(1000);\t&#125;&#125; 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]},{"title":"如何查看自己使用的板子的时钟频率","path":"/2023/04/13/如何查看自己使用的板子的时钟频率/","content":"注：此文章参照正点原子官方delay函数代码 如何查看自己板子的时钟频率首先在main函数文件下添加下面的代码： 12RCC_ClocksTypeDef get_rcc_clock; RCC_GetClocksFreq(&amp;get_rcc_clock); main函数中的代码 1234567891011121314151617181920212223242526#include &quot;stm32f10x.h&quot; // Device header#include &quot;port.h&quot;#include &quot;delay.h&quot;RCC_ClocksTypeDef get_rcc_clock; void led_init()&#123;\tGPIO_InitTypeDef GPIO_InitStruct;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125;int main()&#123;\tRCC_GetClocksFreq(&amp;get_rcc_clock);\tled_init();\tdelay_init();\twhile(1)\t&#123; PAout(0)=1; delay_ms(1000); PAout(0)=0; delay_ms(1000);\t&#125;&#125; 然后点击keil中的调试按钮 对get_rcc_clock变量进行观察 调试到获取时钟频率的步骤 SYSCLK_Frequency就是相关的获取频率的变量，将其转换为十进制即可。 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]},{"title":"delay延时函数","path":"/2023/04/13/SysTick延时函数/","content":"注：此文章参照正点原子官方delay函数代码 delay.c函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;delay.h&quot;static u8 fac_us=0; //usÑÓÊ±±¶³ËÊý static u16 fac_ms=0; //msÑÓÊ±±¶³ËÊý,ÔÚucosÏÂ,´ú±íÃ¿¸ö½ÚÅÄµÄmsÊý void delay_init()&#123;\tSysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);\t//Ñ¡ÔñÍâ²¿Ê±ÖÓ HCLK/8\tfac_us=SystemCoreClock/8000000; //ÎªÏµÍ³Ê±ÖÓµÄ1/8 fac_ms=(u16)fac_us*1000; //·ÇOSÏÂ,´ú±íÃ¿¸ömsÐèÒªµÄsystickÊ±ÖÓÊý &#125; //ÑÓÊ±nus//nusÎªÒªÑÓÊ±µÄusÊý. void delay_us(u32 nus)&#123; u32 temp; SysTick-&gt;LOAD=nus*fac_us; //Ê±¼ä¼ÓÔØ SysTick-&gt;VAL=0x00; //Çå¿Õ¼ÆÊýÆ÷\tSysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;\t//¿ªÊ¼µ¹Êý do\t&#123; temp=SysTick-&gt;CTRL;\t&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //µÈ´ýÊ±¼äµ½´ï SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;\t//¹Ø±Õ¼ÆÊýÆ÷\tSysTick-&gt;VAL =0X00; //Çå¿Õ¼ÆÊýÆ÷ &#125;//ÑÓÊ±nms//×¢ÒânmsµÄ·¶Î§//SysTick-&gt;LOADÎª24Î»¼Ä´æÆ÷,ËùÒÔ,×î´óÑÓÊ±Îª://nms&lt;=0xffffff*8*1000/SYSCLK//SYSCLKµ¥Î»ÎªHz,nmsµ¥Î»Îªms//¶Ô72MÌõ¼þÏÂ,nms&lt;=1864 void delay_ms(u16 nms)&#123; u32 temp; SysTick-&gt;LOAD=(u32)nms*fac_ms; //Ê±¼ä¼ÓÔØ(SysTick-&gt;LOADÎª24bit)\tSysTick-&gt;VAL =0x00; //Çå¿Õ¼ÆÊýÆ÷\tSysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;\t//¿ªÊ¼µ¹Êý do\t&#123; temp=SysTick-&gt;CTRL;\t&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //µÈ´ýÊ±¼äµ½´ï SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;\t//¹Ø±Õ¼ÆÊýÆ÷\tSysTick-&gt;VAL =0X00; //Çå¿Õ¼ÆÊýÆ÷ &#125; delay.h函数 123456789#ifndef __DELAY_H#define __DELAY_H #include &quot;stm32f10x.h&quot;void delay_init(void);void delay_ms(u16 nms);void delay_us(u32 nus);#endif 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]},{"title":"滴答定时器","path":"/2023/04/13/滴答定时器/","content":"SysTick定时器被捆绑在NVIC中，用于产生SysTick异常（异常号：15）。滴答中断对操作系统尤其重要。 例如，操作系统可以为多个任务许以不同数目的时间片，确 保没有一个任务能霸占系统；或者把每个定时器周期的某个时间范围赐予特定的任务等，还有操作 系统提供的各种定时功能，都与这个滴答定时器有关。 因此，需要一个定时器来产生周期性的中断，而且最好还让用户程序不能随意访问它的寄存器，以维持操作系统“心跳”的节律。 Cortex-M3处理器内部包含了一个简单的定时器。因为所有的CM3芯片都带有这个定时器，软 件在不同 CM3器件间的移植工作就得以化简。 SysTick定时器能产生中断，CM3为它专门开出一个异常类型，并且在向量表中有它的一席之 地。 SysTick控制及状态寄存器（CTRL） SysTick重装载数值寄存器(LOAD) SysTick当前数值寄存器(VAL) SysTick校准数值寄存器(SysTick) SysTick定时器除了能服务于操作系统之外，还能用于其它目的：如作为一个闹铃，用于测量 时间等。 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]},{"title":"位带操作","path":"/2023/04/12/位带操作/","content":"根据CSDN一位博主的概述，位带操作是对STM32中的一个比特位进行单独的读写操作，例如在C51单片机中P2_0&#x3D;1；这种操作可以直接对一个IO引脚进行操作。但是在STM32中，这样的操作比较复杂。 根据官方COR3手册（第五章）描述，对于CM3类型的芯片，有 两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范 围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，它们还都有自己的“位带别名区”， 位带别名区把每个比特膨胀成一个 32 位的字。 在CM3中使用下面的术语来表示位带存储的相关地址： 位带区：支持位带操作的地址区 位带别名： 对别名地址的访问最终会变换成对位带区的访问 支持位带操作的两个内存区范围是： 120x2000_0000-0x200F_FFFF（SRAM 区中的最低 1MB）0x4000_0000-0x400F_FFFF（片上外设区中的最低 1MB） 将SRAM位带中的一个比特，将其所在字节地址记作A，位序号为n（0&lt;&#x3D;n&lt;&#x3D;7），那么这个比特在别名区的地址是 12AliasAddr＝ 0x22000000+((A-0x20000000)*8+n)*4 =0x22000000+ (A-0x20000000)*32 +n*4 而对于片外的外设带区的一个比特而言，同SRAM差不多一样的操作 12AliasAddr＝ 0x42000000+((A-0x40000000)*8+n)*4 =0x42000000+ (A-0x40000000)*32 +n*4 上式中，“4”表示一个字为 4 个字节，“8”表示一个字节中有 8 个比特。 对于 SRAM 内存区，位带别名的重映射下所示： 位带区 等效的别名地址 0x20000000.0 0x22000000.0 0x20000000.1 0x22000004.0 0x20000000.2 0x22000008.0 …… …… 0x200FFFFC.31 0x23FFFFFC.0 对于片上外设，映射关系如下表所示 位带区 等效的别名地址 0x40000000.0 0x42000000.0 0x40000000.1 0x42000004.0 0x40000000.2 0x42000008.0 …… …… 0x400FFFFC.31 0x43FFFFFC.0 在C语言中并不能直接进行位带操作。C 编译器并不知道同一块内存能够 使用不同的地址来访问，也不知道对位带别名区的访问只对 LSB 有效。 12#define DEVICE_REG0 ((volatile unsigned long *) (0x40000000))*DEVICE_REG0 = 0xAB; //使用正常地址访问寄存器 为简化位带操作，也可以定义一些宏。比如，我们可以建立一个把“位带地址＋位序号”转换 成别名地址的宏，再建立一个把别名地址转换成指针类型的宏： 123456//把“位带地址＋位序号”转换成别名地址的宏#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp; 0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))//把该地址转换成一个指针#define MEM_ADDR(addr) *((volatile unsigned long *) (adr)) 1234在此基础上，我们就可以如下改写代码：MEM_ADDR(DEVICE_REG0) = 0xAB; //使用正常地址访问寄存器MEM_ADDR(DEVICE_REG0)= MEM_ADDR(DEVICE_REG0) | 0x2; //传统做法MEM_ADDR(BITBAND(DEVICE_REG0,1)) = 0x1; //使用位带别名地址 在使用位带操作的时候，要访问变量必须用volatile进行定义，C 编译器并不知道 同一个比特可以有两个地址。所以就要通过 volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回— —这会导致按不同的方式访问同一个位会得到不一致的结果。 例如在正点原子STM32库函数版本中： 123456789101112131415161718192021222324252627282930313233343536#define BITBAND(addr， bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2)) #define MEM_ADDR(addr) *((volatile unsigned long *)(addr)) #define BIT_ADDR(addr， bitnum) MEM_ADDR(BITBAND(addr， bitnum)) //IO 口地址映射#define GPIOA_ODR_Addr (GPIOA_BASE+12) //0x4001080C #define GPIOB_ODR_Addr (GPIOB_BASE+12) //0x40010C0C #define GPIOC_ODR_Addr (GPIOC_BASE+12) //0x4001100C #define GPIOD_ODR_Addr (GPIOD_BASE+12) //0x4001140C #define GPIOE_ODR_Addr (GPIOE_BASE+12) //0x4001180C #define GPIOF_ODR_Addr (GPIOF_BASE+12) //0x40011A0C #define GPIOG_ODR_Addr (GPIOG_BASE+12) //0x40011E0C #define GPIOA_IDR_Addr (GPIOA_BASE+8) //0x40010808 #define GPIOB_IDR_Addr (GPIOB_BASE+8) //0x40010C08 #define GPIOC_IDR_Addr (GPIOC_BASE+8) //0x40011008 #define GPIOD_IDR_Addr (GPIOD_BASE+8) //0x40011408 #define GPIOE_IDR_Addr (GPIOE_BASE+8) //0x40011808 #define GPIOF_IDR_Addr (GPIOF_BASE+8) //0x40011A08 #define GPIOG_IDR_Addr (GPIOG_BASE+8) //0x40011E08 //IO 口操作，只对单一的 IO 口!//确保 n 的值小于 16!#define PAout(n) BIT_ADDR(GPIOA_ODR_Addr，n) //输出#define PAin(n) BIT_ADDR(GPIOA_IDR_Addr，n) //输入#define PBout(n) BIT_ADDR(GPIOB_ODR_Addr，n) //输出#define PBin(n) BIT_ADDR(GPIOB_IDR_Addr，n) //输入#define PCout(n) BIT_ADDR(GPIOC_ODR_Addr，n) //输出#define PCin(n) BIT_ADDR(GPIOC_IDR_Addr，n) //输入#define PDout(n) BIT_ADDR(GPIOD_ODR_Addr，n) //输出#define PDin(n) BIT_ADDR(GPIOD_IDR_Addr，n) //输入#define PEout(n) BIT_ADDR(GPIOE_ODR_Addr，n) //输出#define PEin(n) BIT_ADDR(GPIOE_IDR_Addr，n) //输入#define PFout(n) BIT_ADDR(GPIOF_ODR_Addr，n) //输出#define PFin(n) BIT_ADDR(GPIOF_IDR_Addr，n) //输入#define PGout(n) BIT_ADDR(GPIOG_ODR_Addr，n) //输出#define PGin(n) BIT_ADDR(GPIOG_IDR_Addr，n) //输入 通过上述的操作，可以简单的对IO进行操作。 如对(GPIOA,GPIO_Pin_6)输出高电平 1PAout(6)=1; 如获取一个引脚的电平状态 1if(PAin(14)==1)……; 参考资料 《STM32不完全手册_库函数版本_V3.3》","tags":["STM32"]}]