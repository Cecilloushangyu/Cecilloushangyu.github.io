[{"title":"2. 按键输入","path":"/2023/04/13/按键输入/","content":"2. 按键输入按键输入使用的是浮空输入。 key.c 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;key.h&quot;#include &quot;port.h&quot;#define KEY0 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)#define KEY1 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1)void key_init()&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#125;unsigned char key_Scan()&#123; if(KEY0==0) &#123; delay_ms(10); if(KEY0==0) &#123; while(!KEY0); delay_ms(10); return 1; &#125; &#125; if(KEY1==0) &#123; delay_ms(10); if(KEY1==0) &#123; while(!KEY1); delay_ms(10); return 2; &#125; &#125; return 0;&#125; key.h 123456789#ifndef __KEY_H#define __KEY_H#include &quot;stm32f10x.h&quot; // Device header#include &quot;delay.h&quot;unsigned char key_Scan();void key_init();#endif protuse按键仿真：在protuse仿真中只能使将按钮配置为上拉输入或是下拉输入，否则将会出现按键功能无法实现得情况，此外按键只能如图接法，接上拉电阻或是下拉电阻同样无法生效。","tags":["STM32"]},{"title":"1. 点亮我的第一个LED小灯","path":"/2023/04/13/点亮我的第一个LED小灯/","content":"1. 点亮我的第一个LED小灯123456789101112131415161718192021222324#include &quot;stm32f10x.h&quot; // Device header#include &quot;port.h&quot;//位带操作#include &quot;delay.h&quot;//延时函数void led_init()&#123;\tGPIO_InitTypeDef GPIO_InitStruct;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125;int main()&#123;\tled_init();\tdelay_init();\twhile(1)\t&#123; PAout(0)=1; delay_ms(1000); PAout(0)=0; delay_ms(1000);\t&#125;&#125;","tags":["STM32"]},{"title":"如何查看自己使用的板子的时钟频率","path":"/2023/04/13/如何查看自己使用的板子的时钟频率/","content":"注：此文章参照正点原子官方delay函数代码 如何查看自己板子的时钟频率首先在main函数文件下添加下面的代码： 12RCC_ClocksTypeDef get_rcc_clock; RCC_GetClocksFreq(&amp;get_rcc_clock); main函数中的代码 1234567891011121314151617181920212223242526#include &quot;stm32f10x.h&quot; // Device header#include &quot;port.h&quot;#include &quot;delay.h&quot;RCC_ClocksTypeDef get_rcc_clock; void led_init()&#123;\tGPIO_InitTypeDef GPIO_InitStruct;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125;int main()&#123;\tRCC_GetClocksFreq(&amp;get_rcc_clock);\tled_init();\tdelay_init();\twhile(1)\t&#123; PAout(0)=1; delay_ms(1000); PAout(0)=0; delay_ms(1000);\t&#125;&#125; 然后点击keil中的调试按钮 对get_rcc_clock变量进行观察 调试到获取时钟频率的步骤 SYSCLK_Frequency就是相关的获取频率的变量，将其转换为十进制即可。","tags":["STM32"]},{"title":"SysTick延时函数","path":"/2023/04/13/SysTick延时函数/","content":"delay延时函数注：此文章参照正点原子官方delay函数代码 delay.c函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;delay.h&quot;static u8 fac_us=0; //usÑÓÊ±±¶³ËÊý static u16 fac_ms=0; //msÑÓÊ±±¶³ËÊý,ÔÚucosÏÂ,´ú±íÃ¿¸ö½ÚÅÄµÄmsÊý void delay_init()&#123;\tSysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);\t//Ñ¡ÔñÍâ²¿Ê±ÖÓ HCLK/8\tfac_us=SystemCoreClock/8000000; //ÎªÏµÍ³Ê±ÖÓµÄ1/8 fac_ms=(u16)fac_us*1000; //·ÇOSÏÂ,´ú±íÃ¿¸ömsÐèÒªµÄsystickÊ±ÖÓÊý &#125; //ÑÓÊ±nus//nusÎªÒªÑÓÊ±µÄusÊý. void delay_us(u32 nus)&#123; u32 temp; SysTick-&gt;LOAD=nus*fac_us; //Ê±¼ä¼ÓÔØ SysTick-&gt;VAL=0x00; //Çå¿Õ¼ÆÊýÆ÷\tSysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;\t//¿ªÊ¼µ¹Êý do\t&#123; temp=SysTick-&gt;CTRL;\t&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //µÈ´ýÊ±¼äµ½´ï SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;\t//¹Ø±Õ¼ÆÊýÆ÷\tSysTick-&gt;VAL =0X00; //Çå¿Õ¼ÆÊýÆ÷ &#125;//ÑÓÊ±nms//×¢ÒânmsµÄ·¶Î§//SysTick-&gt;LOADÎª24Î»¼Ä´æÆ÷,ËùÒÔ,×î´óÑÓÊ±Îª://nms&lt;=0xffffff*8*1000/SYSCLK//SYSCLKµ¥Î»ÎªHz,nmsµ¥Î»Îªms//¶Ô72MÌõ¼þÏÂ,nms&lt;=1864 void delay_ms(u16 nms)&#123; u32 temp; SysTick-&gt;LOAD=(u32)nms*fac_ms; //Ê±¼ä¼ÓÔØ(SysTick-&gt;LOADÎª24bit)\tSysTick-&gt;VAL =0x00; //Çå¿Õ¼ÆÊýÆ÷\tSysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;\t//¿ªÊ¼µ¹Êý do\t&#123; temp=SysTick-&gt;CTRL;\t&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //µÈ´ýÊ±¼äµ½´ï SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;\t//¹Ø±Õ¼ÆÊýÆ÷\tSysTick-&gt;VAL =0X00; //Çå¿Õ¼ÆÊýÆ÷ &#125; delay.h函数 123456789#ifndef __DELAY_H#define __DELAY_H #include &quot;stm32f10x.h&quot;void delay_init(void);void delay_ms(u16 nms);void delay_us(u32 nus);#endif","tags":["STM32"]},{"title":"滴答定时器","path":"/2023/04/13/滴答定时器/","content":"SysTick定时器SysTick定时器被捆绑在NVIC中，用于产生SysTick异常（异常号：15）。滴答中断对操作系统尤其重要。 例如，操作系统可以为多个任务许以不同数目的时间片，确 保没有一个任务能霸占系统；或者把每个定时器周期的某个时间范围赐予特定的任务等，还有操作 系统提供的各种定时功能，都与这个滴答定时器有关。 因此，需要一个定时器来产生周期性的中断，而且最好还让用户程序不能随意访问它的寄存器，以维持操作系统“心跳”的节律。 Cortex-M3处理器内部包含了一个简单的定时器。因为所有的CM3芯片都带有这个定时器，软 件在不同 CM3器件间的移植工作就得以化简。 SysTick定时器能产生中断，CM3为它专门开出一个异常类型，并且在向量表中有它的一席之 地。 SysTick控制及状态寄存器（CTRL） SysTick重装载数值寄存器(LOAD) SysTick当前数值寄存器(VAL) SysTick校准数值寄存器(SysTick) SysTick定时器除了能服务于操作系统之外，还能用于其它目的：如作为一个闹铃，用于测量 时间等。","tags":["STM32"]},{"title":"位带操作","path":"/2023/04/12/位带操作/","content":"位带简介根据CSDN一位博主的概述，位带操作是对STM32中的一个比特位进行单独的读写操作，例如在C51单片机中P2_0&#x3D;1；这种操作可以直接对一个IO引脚进行操作。但是在STM32中，这样的操作比较复杂。 根据官方COR3手册（第五章）描述，对于CM3类型的芯片，有 两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范 围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，它们还都有自己的“位带别名区”， 位带别名区把每个比特膨胀成一个 32 位的字。 在CM3中使用下面的术语来表示位带存储的相关地址： 位带区：支持位带操作的地址区 位带别名： 对别名地址的访问最终会变换成对位带区的访问 支持位带操作的两个内存区范围是： 120x2000_0000-0x200F_FFFF（SRAM 区中的最低 1MB）0x4000_0000-0x400F_FFFF（片上外设区中的最低 1MB） 将SRAM位带中的一个比特，将其所在字节地址记作A，位序号为n（0&lt;&#x3D;n&lt;&#x3D;7），那么这个比特在别名区的地址是 12AliasAddr＝ 0x22000000+((A-0x20000000)*8+n)*4 =0x22000000+ (A-0x20000000)*32 +n*4 而对于片外的外设带区的一个比特而言，同SRAM差不多一样的操作 12AliasAddr＝ 0x42000000+((A-0x40000000)*8+n)*4 =0x42000000+ (A-0x40000000)*32 +n*4 上式中，“4”表示一个字为 4 个字节，“8”表示一个字节中有 8 个比特。 对于 SRAM 内存区，位带别名的重映射下所示： 位带区 等效的别名地址 0x20000000.0 0x22000000.0 0x20000000.1 0x22000004.0 0x20000000.2 0x22000008.0 …… …… 0x200FFFFC.31 0x23FFFFFC.0 对于片上外设，映射关系如下表所示 位带区 等效的别名地址 0x40000000.0 0x42000000.0 0x40000000.1 0x42000004.0 0x40000000.2 0x42000008.0 …… …… 0x400FFFFC.31 0x43FFFFFC.0 在C语言中并不能直接进行位带操作。C 编译器并不知道同一块内存能够 使用不同的地址来访问，也不知道对位带别名区的访问只对 LSB 有效。 12#define DEVICE_REG0 ((volatile unsigned long *) (0x40000000))*DEVICE_REG0 = 0xAB; //使用正常地址访问寄存器 为简化位带操作，也可以定义一些宏。比如，我们可以建立一个把“位带地址＋位序号”转换 成别名地址的宏，再建立一个把别名地址转换成指针类型的宏： 123456//把“位带地址＋位序号”转换成别名地址的宏#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp; 0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))//把该地址转换成一个指针#define MEM_ADDR(addr) *((volatile unsigned long *) (adr)) 1234在此基础上，我们就可以如下改写代码：MEM_ADDR(DEVICE_REG0) = 0xAB; //使用正常地址访问寄存器MEM_ADDR(DEVICE_REG0)= MEM_ADDR(DEVICE_REG0) | 0x2; //传统做法MEM_ADDR(BITBAND(DEVICE_REG0,1)) = 0x1; //使用位带别名地址 在使用位带操作的时候，要访问变量必须用volatile进行定义，C 编译器并不知道 同一个比特可以有两个地址。所以就要通过 volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回— —这会导致按不同的方式访问同一个位会得到不一致的结果。 例如在正点原子STM32库函数版本中： 123456789101112131415161718192021222324252627282930313233343536#define BITBAND(addr， bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2)) #define MEM_ADDR(addr) *((volatile unsigned long *)(addr)) #define BIT_ADDR(addr， bitnum) MEM_ADDR(BITBAND(addr， bitnum)) //IO 口地址映射#define GPIOA_ODR_Addr (GPIOA_BASE+12) //0x4001080C #define GPIOB_ODR_Addr (GPIOB_BASE+12) //0x40010C0C #define GPIOC_ODR_Addr (GPIOC_BASE+12) //0x4001100C #define GPIOD_ODR_Addr (GPIOD_BASE+12) //0x4001140C #define GPIOE_ODR_Addr (GPIOE_BASE+12) //0x4001180C #define GPIOF_ODR_Addr (GPIOF_BASE+12) //0x40011A0C #define GPIOG_ODR_Addr (GPIOG_BASE+12) //0x40011E0C #define GPIOA_IDR_Addr (GPIOA_BASE+8) //0x40010808 #define GPIOB_IDR_Addr (GPIOB_BASE+8) //0x40010C08 #define GPIOC_IDR_Addr (GPIOC_BASE+8) //0x40011008 #define GPIOD_IDR_Addr (GPIOD_BASE+8) //0x40011408 #define GPIOE_IDR_Addr (GPIOE_BASE+8) //0x40011808 #define GPIOF_IDR_Addr (GPIOF_BASE+8) //0x40011A08 #define GPIOG_IDR_Addr (GPIOG_BASE+8) //0x40011E08 //IO 口操作，只对单一的 IO 口!//确保 n 的值小于 16!#define PAout(n) BIT_ADDR(GPIOA_ODR_Addr，n) //输出#define PAin(n) BIT_ADDR(GPIOA_IDR_Addr，n) //输入#define PBout(n) BIT_ADDR(GPIOB_ODR_Addr，n) //输出#define PBin(n) BIT_ADDR(GPIOB_IDR_Addr，n) //输入#define PCout(n) BIT_ADDR(GPIOC_ODR_Addr，n) //输出#define PCin(n) BIT_ADDR(GPIOC_IDR_Addr，n) //输入#define PDout(n) BIT_ADDR(GPIOD_ODR_Addr，n) //输出#define PDin(n) BIT_ADDR(GPIOD_IDR_Addr，n) //输入#define PEout(n) BIT_ADDR(GPIOE_ODR_Addr，n) //输出#define PEin(n) BIT_ADDR(GPIOE_IDR_Addr，n) //输入#define PFout(n) BIT_ADDR(GPIOF_ODR_Addr，n) //输出#define PFin(n) BIT_ADDR(GPIOF_IDR_Addr，n) //输入#define PGout(n) BIT_ADDR(GPIOG_ODR_Addr，n) //输出#define PGin(n) BIT_ADDR(GPIOG_IDR_Addr，n) //输入 通过上述的操作，可以简单的对IO进行操作。 如对(GPIOA,GPIO_Pin_6)输出高电平 1PAout(6)=1; 如获取一个引脚的电平状态 1if(PAin(14)==1)……;","tags":["STM32"]}]