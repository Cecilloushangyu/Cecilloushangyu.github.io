[{"title":"3.串口通信","path":"/2023/04/13/串口通信/","content":"3. 串口通信串口通信有一下几个步骤 串口时钟使能，GPIO 时钟使能 串口复位 GPIO端口模式设置 串口参数初始化 开启中断并且初始化NVIC（若是中断开发需要设置） 使能串口 编写中断处理函数 相关函数 串口时钟使能，GPIO 时钟使能 1RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1)； 串口复位。当外设出现异常的时复位设置，实现该外设的复位，然后重新配置 这个外设达到让其重新工作的目的。一般在系统刚开始配置外设的时候，都会先执行复位该外 设的操作。复位的是在函数 USART_DeInit()中完成： 1void USART_DeInit(USART_TypeDef* USARTx);//串口复位 串口参数初始化，串口初始化是通过 USART_Init()函数实现的。 1void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)； 这个函数得第一个参数是指定的串口标号，而第二个参数是一个USART_InitTypeDef类型得结构体指针，该结构体成员的参数需要进行一定的配置。 1234567USART_InitStructure.USART_BaudRate = bound; //波特率;USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为 8 位数据格式USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位USART_InitStructure.USART_HardwareFlowControl= USART_HardwareFlowControl_None; //无硬件数据流控制USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式USART_Init(USART1, &amp;USART_InitStructure); //初始化串口 初始化需要设置的参数为：波特率，字长，停止位，奇偶校验位， 硬件数据流控制，模式（收，发）。 数据发送与接收。STM32 的发送与接收是通过数据寄存器 USART_DR 来实现的，这是 一个双寄存器，包含了 TDR 和 RDR。当向该寄存器写数据的时候，串口就会自动发送，当收 到收据的时候，也是存在该寄存器内。 STM32 库函数操作 USART_DR 寄存器发送数据的函数是： 1void USART_SendData(USART_TypeDef* USARTx, uint16_t Data); 通过该函数向串口寄存器 USART_DR 写入一个数据。 STM32 库函数操作 USART_DR 寄存器读取串口接收到的数据的函数是： 1uint16_t USART_ReceiveData(USART_TypeDef* USARTx); 通过该函数可以读取串口接受到的数据。 串口状态。串口的状态可以通过状态寄存器 USART_SR 读取。USART_SR 的各位描述如下图： RXNE（读数据寄存器非空），当该位被置 1 的时候，就是提示已经有数据被接收到了，并 且可以读出来了。这时候我们要做的就是尽快去读取 USART_DR，通过读 USART_DR 可以将 该位清零，也可以向该位写 0，直接清除。 TC（发送完成），当该位被置位的时候，表示 USART_DR 内的数据已经被发送完成了。如 果设置了这个位的中断，则会产生中断。该位也有两种清零方式：1）读 USART_SR，写 USART_DR。2）直接向该位写 0。 1FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)； 函数的第二个入口参数非常关键，它是标示我们要查看串口的哪种状态，比如上面讲解的 RXNE(读数据寄存器非空)以及 TC(发送完成)。例如我们要判断读寄存器是否非空(RXNE)，操 作库函数的方法是： 1USART_GetFlagStatus(USART1, USART_FLAG_RXNE)； 我们要判断发送是否完成(TC)，操作库函数的方法是： 1USART_GetFlagStatus(USART1, USART_FLAG_TC); 串口使能 1USART_Cmd(USART1, ENABLE); //使能串口 开启串口响应中断。有些时候当我们还需要开启串口中断，那么我们还需要使能串口中 断，使能串口中断的函数是： 1void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState) 函数的第二个入口参数是标示使能串口的类型，也就是使能哪种中断，因为串口的中断类 型有很多种。比如在接收到数据的时候（RXNE 读数据寄存器非空），我们要产生中断，那么我 们开启中断的方法是： 1USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断，接收到数据中断 获取相应中断状态。当我们使能了某个中断的时候，当该中断发生了，就会设置状态寄 存器中的某个标志位。经常我们在中断处理函数中，要判断该中断是哪种中断，使用的函数是： 1ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT) 比如我们使能了串口发送完成中断，那么当中断发生了， 我们便可以在中断处理函数中调用这 个函数来判断到底是否是串口发送完成中断，方法是： 1USART_GetITStatus(USART1, USART_IT_TC)","tags":["STM32"]},{"title":"2. 按键输入","path":"/2023/04/13/按键输入/","content":"2. 按键输入按键输入使用的是浮空输入。 key.c 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;key.h&quot;#include &quot;port.h&quot;#define KEY0 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)#define KEY1 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1)void key_init()&#123;\tGPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#125;unsigned char key_Scan()&#123; if(KEY0==0) &#123; delay_ms(10); if(KEY0==0) &#123; while(!KEY0); delay_ms(10); return 1; &#125; &#125; if(KEY1==0) &#123; delay_ms(10); if(KEY1==0) &#123; while(!KEY1); delay_ms(10); return 2; &#125; &#125; return 0;&#125; key.h 123456789#ifndef __KEY_H#define __KEY_H#include &quot;stm32f10x.h&quot; // Device header#include &quot;delay.h&quot;unsigned char key_Scan();void key_init();#endif protuse按键仿真：在protuse仿真中只能使将按钮配置为上拉输入或是下拉输入，否则将会出现按键功能无法实现得情况，此外按键只能如图接法，接上拉电阻或是下拉电阻同样无法生效。","tags":["STM32"]},{"title":"1. 点亮我的第一个LED小灯","path":"/2023/04/13/点亮我的第一个LED小灯/","content":"1. 点亮我的第一个LED小灯123456789101112131415161718192021222324#include &quot;stm32f10x.h&quot; // Device header#include &quot;port.h&quot;//位带操作#include &quot;delay.h&quot;//延时函数void led_init()&#123;\tGPIO_InitTypeDef GPIO_InitStruct;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125;int main()&#123;\tled_init();\tdelay_init();\twhile(1)\t&#123; PAout(0)=1; delay_ms(1000); PAout(0)=0; delay_ms(1000);\t&#125;&#125;","tags":["STM32"]},{"title":"如何查看自己使用的板子的时钟频率","path":"/2023/04/13/如何查看自己使用的板子的时钟频率/","content":"注：此文章参照正点原子官方delay函数代码 如何查看自己板子的时钟频率首先在main函数文件下添加下面的代码： 12RCC_ClocksTypeDef get_rcc_clock; RCC_GetClocksFreq(&amp;get_rcc_clock); main函数中的代码 1234567891011121314151617181920212223242526#include &quot;stm32f10x.h&quot; // Device header#include &quot;port.h&quot;#include &quot;delay.h&quot;RCC_ClocksTypeDef get_rcc_clock; void led_init()&#123;\tGPIO_InitTypeDef GPIO_InitStruct;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125;int main()&#123;\tRCC_GetClocksFreq(&amp;get_rcc_clock);\tled_init();\tdelay_init();\twhile(1)\t&#123; PAout(0)=1; delay_ms(1000); PAout(0)=0; delay_ms(1000);\t&#125;&#125; 然后点击keil中的调试按钮 对get_rcc_clock变量进行观察 调试到获取时钟频率的步骤 SYSCLK_Frequency就是相关的获取频率的变量，将其转换为十进制即可。","tags":["STM32"]},{"title":"SysTick延时函数","path":"/2023/04/13/SysTick延时函数/","content":"delay延时函数注：此文章参照正点原子官方delay函数代码 delay.c函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;delay.h&quot;static u8 fac_us=0; //usÑÓÊ±±¶³ËÊý static u16 fac_ms=0; //msÑÓÊ±±¶³ËÊý,ÔÚucosÏÂ,´ú±íÃ¿¸ö½ÚÅÄµÄmsÊý void delay_init()&#123;\tSysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);\t//Ñ¡ÔñÍâ²¿Ê±ÖÓ HCLK/8\tfac_us=SystemCoreClock/8000000; //ÎªÏµÍ³Ê±ÖÓµÄ1/8 fac_ms=(u16)fac_us*1000; //·ÇOSÏÂ,´ú±íÃ¿¸ömsÐèÒªµÄsystickÊ±ÖÓÊý &#125; //ÑÓÊ±nus//nusÎªÒªÑÓÊ±µÄusÊý. void delay_us(u32 nus)&#123; u32 temp; SysTick-&gt;LOAD=nus*fac_us; //Ê±¼ä¼ÓÔØ SysTick-&gt;VAL=0x00; //Çå¿Õ¼ÆÊýÆ÷\tSysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;\t//¿ªÊ¼µ¹Êý do\t&#123; temp=SysTick-&gt;CTRL;\t&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //µÈ´ýÊ±¼äµ½´ï SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;\t//¹Ø±Õ¼ÆÊýÆ÷\tSysTick-&gt;VAL =0X00; //Çå¿Õ¼ÆÊýÆ÷ &#125;//ÑÓÊ±nms//×¢ÒânmsµÄ·¶Î§//SysTick-&gt;LOADÎª24Î»¼Ä´æÆ÷,ËùÒÔ,×î´óÑÓÊ±Îª://nms&lt;=0xffffff*8*1000/SYSCLK//SYSCLKµ¥Î»ÎªHz,nmsµ¥Î»Îªms//¶Ô72MÌõ¼þÏÂ,nms&lt;=1864 void delay_ms(u16 nms)&#123; u32 temp; SysTick-&gt;LOAD=(u32)nms*fac_ms; //Ê±¼ä¼ÓÔØ(SysTick-&gt;LOADÎª24bit)\tSysTick-&gt;VAL =0x00; //Çå¿Õ¼ÆÊýÆ÷\tSysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;\t//¿ªÊ¼µ¹Êý do\t&#123; temp=SysTick-&gt;CTRL;\t&#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //µÈ´ýÊ±¼äµ½´ï SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;\t//¹Ø±Õ¼ÆÊýÆ÷\tSysTick-&gt;VAL =0X00; //Çå¿Õ¼ÆÊýÆ÷ &#125; delay.h函数 123456789#ifndef __DELAY_H#define __DELAY_H #include &quot;stm32f10x.h&quot;void delay_init(void);void delay_ms(u16 nms);void delay_us(u32 nus);#endif","tags":["STM32"]},{"title":"滴答定时器","path":"/2023/04/13/滴答定时器/","content":"SysTick定时器SysTick定时器被捆绑在NVIC中，用于产生SysTick异常（异常号：15）。滴答中断对操作系统尤其重要。 例如，操作系统可以为多个任务许以不同数目的时间片，确 保没有一个任务能霸占系统；或者把每个定时器周期的某个时间范围赐予特定的任务等，还有操作 系统提供的各种定时功能，都与这个滴答定时器有关。 因此，需要一个定时器来产生周期性的中断，而且最好还让用户程序不能随意访问它的寄存器，以维持操作系统“心跳”的节律。 Cortex-M3处理器内部包含了一个简单的定时器。因为所有的CM3芯片都带有这个定时器，软 件在不同 CM3器件间的移植工作就得以化简。 SysTick定时器能产生中断，CM3为它专门开出一个异常类型，并且在向量表中有它的一席之 地。 SysTick控制及状态寄存器（CTRL） SysTick重装载数值寄存器(LOAD) SysTick当前数值寄存器(VAL) SysTick校准数值寄存器(SysTick) SysTick定时器除了能服务于操作系统之外，还能用于其它目的：如作为一个闹铃，用于测量 时间等。","tags":["STM32"]},{"title":"位带操作","path":"/2023/04/12/位带操作/","content":"位带简介根据CSDN一位博主的概述，位带操作是对STM32中的一个比特位进行单独的读写操作，例如在C51单片机中P2_0&#x3D;1；这种操作可以直接对一个IO引脚进行操作。但是在STM32中，这样的操作比较复杂。 根据官方COR3手册（第五章）描述，对于CM3类型的芯片，有 两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范 围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，它们还都有自己的“位带别名区”， 位带别名区把每个比特膨胀成一个 32 位的字。 在CM3中使用下面的术语来表示位带存储的相关地址： 位带区：支持位带操作的地址区 位带别名： 对别名地址的访问最终会变换成对位带区的访问 支持位带操作的两个内存区范围是： 120x2000_0000-0x200F_FFFF（SRAM 区中的最低 1MB）0x4000_0000-0x400F_FFFF（片上外设区中的最低 1MB） 将SRAM位带中的一个比特，将其所在字节地址记作A，位序号为n（0&lt;&#x3D;n&lt;&#x3D;7），那么这个比特在别名区的地址是 12AliasAddr＝ 0x22000000+((A-0x20000000)*8+n)*4 =0x22000000+ (A-0x20000000)*32 +n*4 而对于片外的外设带区的一个比特而言，同SRAM差不多一样的操作 12AliasAddr＝ 0x42000000+((A-0x40000000)*8+n)*4 =0x42000000+ (A-0x40000000)*32 +n*4 上式中，“4”表示一个字为 4 个字节，“8”表示一个字节中有 8 个比特。 对于 SRAM 内存区，位带别名的重映射下所示： 位带区 等效的别名地址 0x20000000.0 0x22000000.0 0x20000000.1 0x22000004.0 0x20000000.2 0x22000008.0 …… …… 0x200FFFFC.31 0x23FFFFFC.0 对于片上外设，映射关系如下表所示 位带区 等效的别名地址 0x40000000.0 0x42000000.0 0x40000000.1 0x42000004.0 0x40000000.2 0x42000008.0 …… …… 0x400FFFFC.31 0x43FFFFFC.0 在C语言中并不能直接进行位带操作。C 编译器并不知道同一块内存能够 使用不同的地址来访问，也不知道对位带别名区的访问只对 LSB 有效。 12#define DEVICE_REG0 ((volatile unsigned long *) (0x40000000))*DEVICE_REG0 = 0xAB; //使用正常地址访问寄存器 为简化位带操作，也可以定义一些宏。比如，我们可以建立一个把“位带地址＋位序号”转换 成别名地址的宏，再建立一个把别名地址转换成指针类型的宏： 123456//把“位带地址＋位序号”转换成别名地址的宏#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp; 0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))//把该地址转换成一个指针#define MEM_ADDR(addr) *((volatile unsigned long *) (adr)) 1234在此基础上，我们就可以如下改写代码：MEM_ADDR(DEVICE_REG0) = 0xAB; //使用正常地址访问寄存器MEM_ADDR(DEVICE_REG0)= MEM_ADDR(DEVICE_REG0) | 0x2; //传统做法MEM_ADDR(BITBAND(DEVICE_REG0,1)) = 0x1; //使用位带别名地址 在使用位带操作的时候，要访问变量必须用volatile进行定义，C 编译器并不知道 同一个比特可以有两个地址。所以就要通过 volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回— —这会导致按不同的方式访问同一个位会得到不一致的结果。 例如在正点原子STM32库函数版本中： 123456789101112131415161718192021222324252627282930313233343536#define BITBAND(addr， bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2)) #define MEM_ADDR(addr) *((volatile unsigned long *)(addr)) #define BIT_ADDR(addr， bitnum) MEM_ADDR(BITBAND(addr， bitnum)) //IO 口地址映射#define GPIOA_ODR_Addr (GPIOA_BASE+12) //0x4001080C #define GPIOB_ODR_Addr (GPIOB_BASE+12) //0x40010C0C #define GPIOC_ODR_Addr (GPIOC_BASE+12) //0x4001100C #define GPIOD_ODR_Addr (GPIOD_BASE+12) //0x4001140C #define GPIOE_ODR_Addr (GPIOE_BASE+12) //0x4001180C #define GPIOF_ODR_Addr (GPIOF_BASE+12) //0x40011A0C #define GPIOG_ODR_Addr (GPIOG_BASE+12) //0x40011E0C #define GPIOA_IDR_Addr (GPIOA_BASE+8) //0x40010808 #define GPIOB_IDR_Addr (GPIOB_BASE+8) //0x40010C08 #define GPIOC_IDR_Addr (GPIOC_BASE+8) //0x40011008 #define GPIOD_IDR_Addr (GPIOD_BASE+8) //0x40011408 #define GPIOE_IDR_Addr (GPIOE_BASE+8) //0x40011808 #define GPIOF_IDR_Addr (GPIOF_BASE+8) //0x40011A08 #define GPIOG_IDR_Addr (GPIOG_BASE+8) //0x40011E08 //IO 口操作，只对单一的 IO 口!//确保 n 的值小于 16!#define PAout(n) BIT_ADDR(GPIOA_ODR_Addr，n) //输出#define PAin(n) BIT_ADDR(GPIOA_IDR_Addr，n) //输入#define PBout(n) BIT_ADDR(GPIOB_ODR_Addr，n) //输出#define PBin(n) BIT_ADDR(GPIOB_IDR_Addr，n) //输入#define PCout(n) BIT_ADDR(GPIOC_ODR_Addr，n) //输出#define PCin(n) BIT_ADDR(GPIOC_IDR_Addr，n) //输入#define PDout(n) BIT_ADDR(GPIOD_ODR_Addr，n) //输出#define PDin(n) BIT_ADDR(GPIOD_IDR_Addr，n) //输入#define PEout(n) BIT_ADDR(GPIOE_ODR_Addr，n) //输出#define PEin(n) BIT_ADDR(GPIOE_IDR_Addr，n) //输入#define PFout(n) BIT_ADDR(GPIOF_ODR_Addr，n) //输出#define PFin(n) BIT_ADDR(GPIOF_IDR_Addr，n) //输入#define PGout(n) BIT_ADDR(GPIOG_ODR_Addr，n) //输出#define PGin(n) BIT_ADDR(GPIOG_IDR_Addr，n) //输入 通过上述的操作，可以简单的对IO进行操作。 如对(GPIOA,GPIO_Pin_6)输出高电平 1PAout(6)=1; 如获取一个引脚的电平状态 1if(PAin(14)==1)……;","tags":["STM32"]}]